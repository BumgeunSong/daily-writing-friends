/**
 * Recovery History Generation Functionality
 * 
 * Implements REQ-110: RecoveryHistory Rebuild with deterministic recoveryIds
 * Uses FNV-1a hashing for consistent, deterministic results across runs
 * 
 * This module handles creating recovery history records during simulation
 * with deterministic recoveryId generation.
 */

import { Timestamp } from 'firebase-admin/firestore';
import { generateRecoveryId } from './recoveryIdUtils';
import { 
  RecoveryEvent, 
  SimulationResult,
} from './types';

/**
 * Create a recovery history record from a recovery event
 * Generates deterministic recoveryId using FNV-1a hash
 */
export function createRecoveryHistoryRecord(recoveryEvent: RecoveryEvent): RecoveryEvent {
  if (!recoveryEvent.missedDate || !recoveryEvent.recoveryDate) {
    throw new Error('Recovery event must have missedDate and recoveryDate');
  }
  
  // Convert date strings to timestamps for hash generation
  const missedTimestamp = Timestamp.fromDate(new Date(`${recoveryEvent.missedDate}T00:00:00Z`));
  const recoveryTimestamp = Timestamp.fromDate(new Date(`${recoveryEvent.recoveryDate}T00:00:00Z`));
  
  // Generate deterministic recoveryId
  const recoveryId = generateRecoveryId(missedTimestamp, recoveryTimestamp);
  
  return {
    ...recoveryEvent,
    recoveryId,
    successful: recoveryEvent.postsWritten >= recoveryEvent.postsRequired,
  };
}

/**
 * Build complete recovery history for a simulation result
 * Processes all recovery events and assigns deterministic IDs
 */
export function buildRecoveryHistoryForSimulation(
  simulationResult: SimulationResult
): RecoveryEvent[] {
  if (!simulationResult.recoveryEvents?.length) {
    return [];
  }
  
  return simulationResult.recoveryEvents.map(event => 
    createRecoveryHistoryRecord(event)
  );
}

/**
 * Validate that recovery history is deterministic between runs
 * Used for testing and validation purposes
 */
export function validateRecoveryHistoryDeterminism(
  history1: RecoveryEvent[],
  history2: RecoveryEvent[]
): boolean {
  if (history1.length !== history2.length) {
    return false;
  }
  
  for (let i = 0; i < history1.length; i++) {
    const record1 = history1[i];
    const record2 = history2[i];
    
    // Check that all fields match
    if (
      record1.recoveryId !== record2.recoveryId ||
      record1.missedDate !== record2.missedDate ||
      record1.recoveryDate !== record2.recoveryDate ||
      record1.postsRequired !== record2.postsRequired ||
      record1.postsWritten !== record2.postsWritten ||
      record1.successful !== record2.successful
    ) {
      return false;
    }
  }
  
  return true;
}

/**
 * Create a recovery event from simulation parameters
 * Used during day-by-day simulation processing
 */
export function createRecoveryEventFromSimulation(
  missedDate: string,
  recoveryDate: string,
  postsRequired: number,
  postsWritten: number
): RecoveryEvent {
  return {
    missedDate,
    recoveryDate,
    postsRequired,
    postsWritten,
    recoveryId: '', // Will be generated by createRecoveryHistoryRecord
    successful: postsWritten >= postsRequired,
  };
}

/**
 * Merge recovery events from multiple simulation phases
 * Handles cases where simulation is run in phases or batches
 */
export function mergeRecoveryEvents(
  ...eventArrays: RecoveryEvent[][]
): RecoveryEvent[] {
  const allEvents: RecoveryEvent[] = [];
  
  eventArrays.forEach(eventArray => {
    allEvents.push(...eventArray);
  });
  
  // Sort by missed date, then recovery date for consistency
  return allEvents.sort((a, b) => {
    const missedComparison = a.missedDate.localeCompare(b.missedDate);
    if (missedComparison !== 0) {
      return missedComparison;
    }
    return a.recoveryDate.localeCompare(b.recoveryDate);
  });
}

/**
 * Filter recovery events by date range
 * Used when simulation needs to focus on specific time periods
 */
export function filterRecoveryEventsByDateRange(
  events: RecoveryEvent[],
  fromDate: string,
  toDate: string
): RecoveryEvent[] {
  return events.filter(event => 
    event.missedDate >= fromDate && 
    event.recoveryDate <= toDate
  );
}

/**
 * Group recovery events by outcome (successful vs failed)
 * Useful for statistics and analysis
 */
export function groupRecoveryEventsByOutcome(events: RecoveryEvent[]): {
  successful: RecoveryEvent[];
  failed: RecoveryEvent[];
} {
  const successful: RecoveryEvent[] = [];
  const failed: RecoveryEvent[] = [];
  
  events.forEach(event => {
    if (event.successful) {
      successful.push(event);
    } else {
      failed.push(event);
    }
  });
  
  return { successful, failed };
}

/**
 * Calculate recovery statistics from a list of events
 * Provides insights into recovery patterns and success rates
 */
export function calculateRecoveryStatistics(events: RecoveryEvent[]): {
  totalRecoveries: number;
  successfulRecoveries: number;
  failedRecoveries: number;
  successRate: number;
  weekdayRecoveries: number;
  fridayRecoveries: number;
} {
  if (!events.length) {
    return {
      totalRecoveries: 0,
      successfulRecoveries: 0,
      failedRecoveries: 0,
      successRate: 0,
      weekdayRecoveries: 0,
      fridayRecoveries: 0,
    };
  }
  
  const { successful, failed } = groupRecoveryEventsByOutcome(events);
  
  // Count weekday vs Friday recoveries
  let weekdayRecoveries = 0;
  let fridayRecoveries = 0;
  
  events.forEach(event => {
    if (event.postsRequired === 2) {
      weekdayRecoveries++; // Weekday recovery requires 2 posts
    } else if (event.postsRequired === 1) {
      fridayRecoveries++; // Friday recovery requires 1 post
    }
  });
  
  return {
    totalRecoveries: events.length,
    successfulRecoveries: successful.length,
    failedRecoveries: failed.length,
    successRate: events.length > 0 ? successful.length / events.length : 0,
    weekdayRecoveries,
    fridayRecoveries,
  };
}

/**
 * Validate recovery event data integrity
 * Ensures all required fields are present and valid
 */
export function validateRecoveryEvent(event: RecoveryEvent): boolean {
  try {
    // Check required fields
    if (!event.missedDate || !event.recoveryDate) {
      return false;
    }
    
    // Validate date format
    if (!/^\d{4}-\d{2}-\d{2}$/.test(event.missedDate) || 
        !/^\d{4}-\d{2}-\d{2}$/.test(event.recoveryDate)) {
      return false;
    }
    
    // Check numeric fields
    if (typeof event.postsRequired !== 'number' || 
        typeof event.postsWritten !== 'number' ||
        event.postsRequired < 0 || 
        event.postsWritten < 0) {
      return false;
    }
    
    // Validate success calculation
    const expectedSuccess = event.postsWritten >= event.postsRequired;
    if (event.successful !== expectedSuccess) {
      return false;
    }
    
    // Validate recoveryId format if present
    if (event.recoveryId && !/^[0-9a-f]{8}$/.test(event.recoveryId)) {
      return false;
    }
    
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Clean and validate an array of recovery events
 * Removes invalid events and logs warnings
 */
export function cleanRecoveryEvents(events: RecoveryEvent[]): RecoveryEvent[] {
  return events.filter((event, index) => {
    const isValid = validateRecoveryEvent(event);
    if (!isValid) {
      console.warn(`Invalid recovery event at index ${index}:`, event);
    }
    return isValid;
  });
}